---
title: 面试通用版
---
直接打开在这上面一个个做回答即可了
如果不按照这个准备，很难通过，因为这些都是经验要重视

【每位候选人为了保证通过率，建议做好根据这份面试辅导准备一份属于自己的回答思路提供哈，到时候面试就会有些基本的回答思路和方向，也不会导致面试突然短路或者没有思路和方向，大家一起努力】

面试小TIPS：
1、自我介绍：姓名，工作多久，从事什么工作，擅长使用的技术 (不要说太多自己不擅长不太会的技术避开)
【再结合一些自己的能说的反向，自我介绍简单说一下即可，不用说太久，主要是为了让面试官好提问。】



2、技术上：以原理及项目中的使用情况为主，尤其是针对我发您的岗位技能要求去匹配对应上 在面试的时候可以重点说说，加分【重点是要结合到项目使用的去说，而且要多说些原理和理论，尽量避开不太擅长的技术点，省的被深入问】 
一定要在面试之前把您的简历上提及到的【个人技能，专业技能】板块每写到的一个技能点都提前去知乎，百度再次搜搜原理和理论点，复制下来确保被提问的时候能回答上来


1.	熟练掌握Java基础部分相关知识，对面向对象有深刻的理解，有良好的编码习惯。
HashMap 红黑树  实现

HashMap 和hashtable有什么区别
相同点：
hashmap和Hashtable都实现了map、Cloneable（可克隆）、Serializable（可序列化）这三个接口
不同点：
	底层数据结构不同:jdk1.7底层都是数组+链表,但jdk1.8 HashMap加入了红黑树
	Hashtable 是不允许键或值为 null 的，HashMap 的键值则都可以为 null。
	添加key-value的hash值算法不同：HashMap添加元素时，是使用自定义的哈希算法,而HashTable是直接采用key的hashCode()
	实现方式不同：Hashtable 继承的是 Dictionary类，而 HashMap 继承的是 AbstractMap 类。
	初始化容量不同：HashMap 的初始容量为：16，Hashtable 初始容量为：11，两者的负载因子默认都是：0.75。
	扩容机制不同：当已用容量>总容量 * 负载因子时，HashMap 扩容规则为当前容量翻倍，Hashtable 扩容规则为当前容量翻倍 +1。
	支持的遍历种类不同：HashMap只支持Iterator遍历,而HashTable支持Iterator和Enumeration两种方式遍历
	迭代器不同：HashMap的迭代器(Iterator)是fail-fast迭代器，而Hashtable的enumerator迭代器不是fail-fast的。所以当有其它线程改变了HashMap的结构（增加或者移除元素），将会抛出ConcurrentModificationException，但迭代器本身的remove()方法移除元素则不会抛出ConcurrentModificationException异常。但这并不是一个一定发生的行为，要看JVM。而Hashtable 则不会。
	部分API不同：HashMap不支持contains(Object value)方法，没有重写toString()方法,而HashTable支持contains(Object value)方法，而且重写了toString()方法
	同步性不同: Hashtable是同步(synchronized)的，适用于多线程环境,
	而hashmap不是同步的，适用于单线程环境。多个线程可以共享一个Hashtable；而如果没有正确的同步的话，多个线程是不能共享HashMap的。
	由于Hashtable是线程安全的也是synchronized，所以在单线程环境下它比HashMap要慢。如果你不需要同步，只需要单一线程，那么使用HashMap性能要好过Hashtable。


2.	掌握 spring框架核心原理 

.IOC反转控制 ：控制权 由对象本身转向容器，由容器根据配置文件创建对象实例并实现各个对象之间的关系。

AOP面向切面编程：a.静态代理：根据每个具体类分别编写代理类根据一个接口编写一个代理类，b。动态代理，针对一个方面编写一个Invocationhandler,然后借用jdk反射包中的proxy类为各种接口生成相应的代理类

1使用spring，没有new对象，我们把创建的任务交给spring框架来管理
2.spring是一个容器框架，可以配置各种bean如（action/server/domain/dao/）并且维护bean与bean之间的关系，当我们要使用某个bean时，我们可以调用getbean（id）；
 
3.	熟练掌握springMVC、Hibernate、MyBatis框架开发 
   Hibernate 和 Mybatis的区别：
1.两者最大的区别：

针对简单逻辑，Hibernate和MyBatis都有相应的代码生成工具，可以生成简单基本的DAO层方法。

针对高级查询，Mybatis需要手动编写SQL语句，以及ResultMap。而Hibernate有良好的映射机制，开发者无需关心SQL的生成与结果映射，可以更专注于业务流程。

2.开发难度对比

Hibernate的开发难度要大于Mybatis。主要由于Hibernate比较复杂、庞大，学习周期较长。

而Mybatis则相对简单一些，并且Mybatis主要依赖于sql的书写，让开发者感觉更熟悉。

3.sql书写比较

Mybatis的SQL是手动编写的，所以可以按需求指定查询的字段。不过没有自己的日志统计，所以要借助log4j来记录日志。

Hibernate也可以自己写SQL来指定需要查询的字段，但这样就破坏了Hibernate开发的简洁性。不过Hibernate具有自己的日志统计。

4.数据库扩展性比较

Mybatis由于所有SQL都是依赖数据库书写的，所以扩展性，迁移性比较差。

Hibernate与数据库具体的关联都在XML中，所以HQL对具体是用什么数据库并不是很关心。

5.缓存机制比较

相同点：Hibernate和Mybatis的二级缓存除了采用系统默认的缓存机制外，都可以通过实现你自己的缓存或为其他第三方缓存方案，创建适配器来完全覆盖缓存行为。

不同点：Hibernate的二级缓存配置在SessionFactory生成的配置文件中进行详细配置，然后再在具体的表-对象映射中配置是那种缓存。

MyBatis的二级缓存配置都是在每个具体的表-对象映射中进行详细配置，这样针对不同的表可以自定义不同的缓存机制。并且Mybatis可以在命名空间中共享相同的缓存配置和实例，通过Cache-ref来实现。

两者比较：因为Hibernate对查询对象有着良好的管理机制，用户无需关心SQL。所以在使用二级缓存时如果出现脏数据，系统会报出错误并提示。

而MyBatis在这一方面，使用二级缓存时需要特别小心。如果不能完全确定数据更新操作的波及范围，避免Cache的盲目使用。否则，脏数据的出现会给系统的正常运行带来很大的隐患。

6.总结：

mybatis：小巧、方便、高效、简单、直接、半自动
hibernate：强大、方便、高效、复杂、绕弯子、全自动

Hibernate与MyBatis都可以是通过SessionFactoryBuider由XML配置文件生成SessionFactory，然后由SessionFactory 生成Session，最后由Session来开启执行事务和SQL语句。

而MyBatis的优势是MyBatis可以进行更为细致的SQL优化，可以减少查询字段，并且容易掌握。

Hibernate的优势是DAO层开发比MyBatis简单，Mybatis需要维护SQL和结果映射。数据库移植性很好，MyBatis的数据库移植性不好，不同的数据库需要写不同SQL。有更好的二级缓存机制，可以使用第三方缓存。MyBatis本身提供的缓存机制不佳。

mybatis：

1. 入门简单，即学即用，提供了数据库查询的自动对象绑定功能，而且延续了很好的SQL使用经验，对于没有那么高的对象模型要求的项目来说，相当完美。

2. 可以进行更为细致的SQL优化，可以减少查询字段。

3. 缺点就是框架还是比较简陋，功能尚有缺失，虽然简化了数据绑定代码，但是整个底层数据库查询实际还是要自己写的，工作量也比较大，而且不太容易适应快速数据库修改。

4. 二级缓存机制不佳。

hibernate：

1. 功能强大，数据库无关性好，O/R映射能力强，如果你对Hibernate相当精通，而且对Hibernate进行了适当的封装，那么你的项目整个持久层代码会相当简单，需要写的代码很少，开发速度很快，非常爽。

2. 有更好的二级缓存机制，可以使用第三方缓存。

3. 缺点就是学习门槛不低，要精通门槛更高，而且怎么设计O/R映射，在性能和对象模型之间如何权衡取得平衡，以及怎样用好Hibernate方面需要你的经验和能力都很强才行。

SpringMVC HandleMapping 


4.	熟练掌握springcloud alibaba微服务框架开发 
注册中心：Nacos：
客户端启动时会将当前服务的信息包含ip、端口号、服务名、集群名等信息封装为一个Instance对象，然后创建一个定时任务，每隔一段时间向Nacos服务器发送PUT请求并携带相关信息。
nacos服务器端在接收到心跳请求后，会去检查当前服务列表中有没有该实例，如果没有的话将当前服务实例重新注册，注册完成后立即开启一个异步任务，更新客户端实例的最后心跳时间，如果当前实例是非健康状态则将其改为健康状态。
心跳定时任务创建完成后，通过POST请求将当前服务实例信息注册进nacos服务器。
nacos服务器端在接收到注册实例请求后，会将请求携带的数据封装为一个Instance对象，然后为这个服务实例创建一个服务Service，一个Service下可能有多个服务实例，服务在Nacos保存到一个ConcurrentHashMap中
 
配置中心：Nacos：
 
负载均衡：Ribbon、openFeign：

Ribbon是Netflix发布的开源项目，主要功能是提供客户端的软件负载均衡算法和服务调用。（轮询、RandomRule 随机、RetryRule轮询重试、WeightedResponseTimeRule响应速度决定权重、BestAvailableRule最优可用、ZoneAvoidanceRule区域内可用性能最优）
使用Ribbon+RestTemplate时，利用RestTemplate对http请求的封装处理，形成了一套模板化的调用方法。但实际开发中，往往一个接口会被多处调用，所以通常都会针对每个微服务自行封装一些客户端类来包装这些依赖服务的调用。
利用Ribbon维护了服务列表信息，并通过轮询实现了客户端的负载均衡。而与Ribbon不同的是，通过feign只需要定义服务绑定接口且以声明的方法，优雅而简单的实现了服务调用。

服务监控熔断：Sentinel：
对于同一个资源或者不同资源可以分别创建多条限流规则，FlowSlot会对该资源的所有限流规则依次遍历，直到有规则触发限流或者所有规则遍历完毕。

限流规则主要由下面几个因素组成：

resource：资源名，即限流规则的作用对象
count : 限流阈值
grade : 限流阈值类型（QPS 或并发线程数）
limitApp : 流控针对的调用来源，若为 default 则不区分调用来源
strategy : 限流策略（基于调用关系的流量控制）
controlBehavior : 流量控制效果（直接拒绝、Warm Up、匀速排队）
Sentinel中提供了两个限流纬度：

并发线程数 并发线程数控制参数配置（并发线程数控制通常在调用端进行配置）：
1.	grade: RuleConstant.FLOW_GRADE_THREAD
2.	count: 此时它的含义是并发线程数量

QPS
	直接拒绝（CONTROL_BEHAVIOR_DEFAULT）
	Warm Up（CONTROL_BEHAVIOR_WARM_UP）
	匀速排队（CONTROL_BEHAVIOR_RATE_LIMITER，漏桶算法 ）
	冷启动+匀速器（CONTROL_BEHAVIOR_WARM_UP_RATE_LIMITER），除了让流量缓慢增
加，还还控制的了请求的间隔时间，让请求均匀速度通过。
 
也就是说，可以选择根据不同的纬度，根据这些纬度的指标去匹配限流规则，一旦达到阈值，则直接触发流量控制。
默认情况下是根据QPS来限流的，这个属性是通过grade进行设置。
 
网关：Gateway：
客户端向Spring Cloud Gateway发出请求。如果网关处理程序映射确定请求与路由匹配，则将其发送到网关Web处理程序。该处理程序通过特定于请求的过滤器链运行请求。筛选器由虚线分隔的原因是，筛选器可以在发送代理请求之前和之后运行逻辑。所有“前置”过滤器逻辑均被执行。然后发出代理请求。发出代理请求后，将运行“后”过滤器逻辑。
调用链监控：Sleuth：
•		耗时分析：通过 Sleuth 可以很方便的了解到每个采样请求的耗时，从而分析出哪些服务调用比较耗时；
•	可视化错误：对于程序未捕捉的异常，可以通过集成 Zipkin 服务界面上看到；
•	链路优化：对于调用比较频繁的服务，可以针对这些服务实施一些优化措施。

分布式事务：Seata：
AT（Auto Transaction）模式是Seata默认的工作模式。需要基于支持本地 ACID 事务的关系型数据库，Java 应用，通过 JDBC 访问数据库。
•	优点：对代码无侵入；并发度高，本地锁在一阶段就会释放；不需要数据库对XA协议的支持。
•	缺点：只能用在支持ACID的关系型数据库；SQL解析还不能支持全部语法
    TCC该模式工作分为三个阶段：prepare/commit/cancel。
•	优点：不依赖本地事务。
•	缺点：回滚逻辑依赖手动编码；业务侵入性较大。
•	
Saga 模式 将一个长事务（T）分解成一系列Sub事务（Ti），每个Sub事务都有对应的补偿动作（Ci），用于撤销Ti事务产生的影响。Sub事务是直接提交到库，在出现异常时，逆向进行补偿。
•	优点：一阶段提交本地事务，无锁，高性能；事件驱动架构，参与者可异步执行，高吞吐；补偿服务易于实现。
•	缺点：不保证隔离性。
XA是基于二阶段提交设计的接口标准。对于支持XA的资源管理器，借助Seata框架的XA模式，会使XA方案更简单易用。使用前提：需要分支数据库支持XA 事务，应用为 Java应用，且使用JDBC访问数据库。
•	优点：继承了XA协议的优势，事务具有强一致性。
•	缺点：同样继承了XA协议的劣势，由于分支事务长时间开启，并发度低。


5.	熟练掌握redis、mybatis 和 mybatis-plus 等主流框架的使用 
Redis 数据类型： string hash  list set zset
数据结构：
String sds
Hash  ： zlist  到一定大小会变成hashtable
List :   quicklist  ，quicklist的Node 都是ziplist,解决了ziplist的 链表更新问题 
Set :  intset或hashtable
Zset:   默认使用ziplist编码，skipList 跳表
如何扩容：
1.当满足我扩容条件，触发扩容时，判断是否在扩容，如果在扩容，或者 扩容的大小跟我现在的ht[0].size一样，这次扩容不做。
 2. new一个新的dictht，大小为ht[0].used * 2（但是必须向上2的幂，比 如6 ，那么大小为8） ，并且ht[1]=新创建的dictht。
 3. 我们有个更大的table了，但是需要把数据迁移到ht[1].table ，所以将 dict的rehashidx（数据迁移的偏移量）赋值为0 ，代表可以进行数据迁 移了，也就是可以rehash了。 
4. 等待数据迁移完成，数据不会马上迁移，而是采用渐进式rehash，慢慢 的把数据迁移到ht[1]，等下我们讲 
5. 当数据迁移完成，ht[0].table=ht[1] ，ht[1] .table = NULL、ht[1] .size = 0、ht[1] .sizemask = 0、 ht[1] .used = 0; 
6. 把dict的rehashidex=-1
高可用：
可持久化（RDB、AOF、RDB+AOF）、
Sentinel哨兵模式、
 单独启用服务区集群管理redis、和选举新的leader
cluster集群
 最少三主三从
MyBatis:

所有SQL语句全部自己写
手动解析实体关系映射转换为MyBatis内部对象注入容器
不支持Lambda形式调用
Mybatis Plus:

强大的条件构造器,满足各类使用需求
内置的Mapper,通用的Service,少量配置即可实现单表大部分CRUD操作
支持Lambda形式调用
提供了基本的CRUD功能,连SQL语句都不需要编写
自动解析实体关系映射转换为MyBatis内部对象注入容器

6.	熟悉ORACLE，mysql多种数据库开发工具 

Mysql： 是轻量级的关系型数据库；开源使用成本较低，安全性较低
Oracle：是重量级的对象型数据库、收费、闭源使用成本较高


7.	熟悉多线程、TCP网络编程 
多线程：
用户线程和守护线程有什么区别？
所谓守护线程，是指在程序运行的时候在后台提供一种通用服务的线程，比如垃圾回收线程就是一个很称职的守护者，并且这种线程并不属于程序中不可或缺的部分。因此，当所有的非守护线程结束时，程序也就终止了，同时会杀死进程中的所有守护线程。反过来说，只要任何非守护线程还在运行，程序就不会终止。
用户线程和守护线程两者几乎没有区别，唯一的不同之处就在于虚拟机的离开：如果用户线程已经全部退出运行了，只剩下守护线程存在了，虚拟机也就退出了。因为没有了被守护者，守护线程也就没有工作可做了，也就没有继续运行程序的必要了
操作共享数据的安全性
如果有多个线程在同时运行，而这些线程可能会同时运行这段代码。程序每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。
其实，线程安全问题都是由全局变量及静态变量引起的。若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作，一般都需要考虑线程同步，否则的话就可能影响线程安全。
如何暂停一条线程？
两种方式暂停一条线程，一个是采取Thread类的sleep()方法,一个是在同步代码中使用wait()方法.
 线程的调度和时间分片？
 java虚拟机采用抢占式调度模型，是指优先让可运行池中优先级高的线程占用CPU，如果可运行池中的线程优先级相同，那么就随机选择一个线程，使其占用CPU。处于运行状态的线程会一直运行，直至它不得不放弃CPU。
线程的调度不是跨平台的，它不仅仅取决于java虚拟机，还依赖于操作系统。在某些操作系统中，只要运行中的线程没有遇到阻塞，就不会放弃CPU；在某些操作系统中，即使线程没有遇到阻塞，也会运行一段时间后放弃CPU，给其它线程运行的机会。
java的线程调度是不分时的，同时启动多个线程后，不能保证各个线程轮流获得均等的CPU时间片。
线程之间如何通信？
多个线程在处理同一个资源，但是处理的动作（线程的任务）却不相同。通过一定的手段使各个线程能有效的利用资源。
通常情况下，一个次级线程要为主线程完成某种特定类型的任务，这就隐含着表示在主线程和次级线程之间需要建立一个通信的通道。一般情况下，有下面的几种方法实现这种通信任务：使用全局变量、使用事件对象、使用消息。
Java中多线程同步是什么？
即当有一个线程在对内存进行操作时，其他线程都不可以对这个内存地址进行操作，直到该线程完成操作， 其他线程才能对该内存地址进行操作，而其他线程又处于等待状态
为什么需要start与run方法，可以只用run方法来完成任务吗？
启动一个线程是调用start()方法，使线程就绪状态，以后可以被调度为运行状态，一个线程必须关联一些具体的执行代码，run()方法是该线程所关联的执行代码。
如果只用run方法仅仅是作为一个对象调用方法执行,并不会开启新的线程,所以不能叫任务.
什么是ThreadLocal类，怎么使用它?
ThreadLocal为解决多线程程序的并发问题提供了一种新的思路。使用这个工具类可以很简洁地编写出优美的多线程程序，ThreadLocal并不是一个Thread，而是Thread的局部变量.
使用:通过ThreadLocal.set()将这个新创建的对象的引用保存到各线程的自己的一个map中，每个线程都有这样一个map，执行ThreadLocal.get()时，各线程从自己的map中取出放进去的对象，因此取出来的是各自自己线程中的对象，ThreadLocal实例是作为map的key来使用的。
Sleep suspend wait 之间有什么区别？		
sleep就是正在执行的线程主动让出cpu，cpu去执行其他线程，在sleep指定的时间过后，cpu才会回到这个线程上继续往下执行，如果当前线程进入了同步锁，sleep方法并不会释放锁，即使当前线程使用sleep方法让出了cpu，但其他被同步锁挡住了的线程也无法得到执行。wait是指在一个已经进入了同步锁的线程内，让自己暂时让出同步锁，以便其他正在等待此锁的线程可以得到同步锁并运行，只有其他线程调用了notify方法，调用wait方法的线程就会解除wait状态和程序可以再次得到锁后继续向下运行。
suspend()方法容易发生死锁。调用suspend()的时候，目标线程会停下来，但却仍然持有在这之前获得的锁定。此时，其他任何线程都不能访问锁定的资源，除非被"挂起"的线程恢复运行。对任何线程来说，如果它们想恢复目标线程，同时又试图使用任何一个锁定的资源，就会造成死锁。所以不应该使用suspend()。
在一个对象上两个线程可以调用两个不同的同步实例方法么？	
不能，因为一个对象已经同步了实例方法，线程获取了对象的对象锁。所以只有执行完该方法释放对象锁后才能执行其它同步方法。
什么是死锁？
死锁就是两个或两个以上的线程被无限的阻塞，线程之间相互等待所需资源。这种情况可能发生在当两个线程尝试获取其它资源的锁，而每个线程又陷入无限等待其它资源锁的释放，除非一个用户进程被终止。
什么是线程饿死，什么是活锁。
活锁指的是任务或者执行者没有被阻塞，由于某些条件没有满足，导致一直重复尝试，失败，尝试，失败。 活锁和死锁的区别在于，处于活锁的实体是在不断的改变状态，所谓的“活”， 而处于死锁的实体表现为等待；活锁有可能自行解开，死锁则不能。
活锁可以认为是一种特殊的饥饿。 下面这个例子在有的文章里面认为是活锁。实际上这只是一种饥饿。因为没有体现出“活”的特点。 假设事务T2再不断的重复尝试获取锁R，那么这个就是活锁。
饿死 ，与死锁和活锁非常相似。是指一个可运行的进程尽管能继续执行，但被调度器无限期地忽视，而不能被调度执行的情况。
多线程的效率问题，同步机制。
如果数据将在线程间共享。例如正在写的数据以后可能被另一个线程读到，或者正在读的数据可能已经被另一个线程写过了，那么这些数据就是共享数据，必须进行同步存取。
都用到了哪些线程池。
Java通过Executors提供四种线程池，分别为：
newCachedThreadPool创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。
newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。
newScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行。
newSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。
newSingleScheduledThreadExecutor
ForkJoinPool 但重点区别在于它每个线程都有一个自己的双端队列来存储分裂出来的子任务
TCP网络编程：
要发送的数据小于TCP发送缓冲区的大小，TCP将多次写入缓冲区的数据一次发送出去，将会发生粘包；
接收数据端的应用层没有及时读取接收缓冲区中的数据，将发生粘包；
要发送的数据大于TCP发送缓冲区剩余空间大小，将会发生拆包；
待发送数据大于MSS（最大报文长度），TCP在传输前将进行拆包。即TCP报文长度-TCP头部长度>MSS。
解决方案：

发送端将每个数据包封装为固定长度
在数据尾部增加特殊字符进行分割
将数据分为两部分，一部分是头部，一部分是内容体；其中头部结构大小固定，且有一个字段声明内容体的大小。

8.	熟悉nginx 、tomcat、docker 部署系统
Nginx : 文件大小：
* client_body_buffer_size 配置请求体缓存区大小, 不配的话，
* client_body_temp_path 设置临时文件存放路径。只有当上传的请求体超出缓存区大小时，才会写到临时文件中
* client_max_body_size 设置上传文件的最大值
Docker 常用命令
docker run -it -v <本地目录绝对路径>:<docker路径> <docker image> /bin/bash

9.	熟练掌握 html、bootstrap，jquery，Vue, React 的前端开发技术； 

10.	熟练使用 svn 版本控制工具和 maven 打包工具； 

11.	熟悉 Linux 环境下常用命令操作，能写简单 shell 脚本;
vmstat 监控系统资源
free命令查看内存使用状态
 

3、项目上：选择1-2个比较熟悉的项目去讲，但面试官更偏向于后端项目、人选能否讲项目及技术讲清楚。简历上提及到项目必须要知道做什么的，您简历上面写到的个人职责是什么，绝对不能出现被问到项目部分回答不上，会大大减分，会让面试官觉得该项目并不是您做的，会被直接淘汰。
1）项目介绍：项目是做什么的，做这个项目的目的是？   
 
2）项目职责：简单阐述团队职责，详细介绍自己所负责的职责（涵盖技术点）及参与的模块
 
3）项目难点：项目中遇到的难题及怎么解决的（面试官问道的时候再说就可以了）

分析速度延迟 ：通过优化sql语句 和加 索引的方式提高分析速度


4 职业发展规划要提前想好简单描述即可 不用多说

因为做开发很多年了，想一直在java方面深耕，如果有机会的话可以往开发管理层去发展。

5 被问到xx技术如果真的没接触过，也不要这么实在直接就说没接触不了解不懂，要表明自己的主观能动性积极性，可以说“了解的，之前接触过，听过，自学过，如果今后在项目中需要用到自己也会尽量学习上手，自学能力还是可以的” 

  之前接触过，听过，如果今后在项目中需要用到自己也会尽量学习上手，自学能力还是可以的


6 被问到加班问题，要表明不排斥加班，互联网经常要加班适应的
（实际上贵公司是不加班的哈哈哈，面试官问这个只是想看看您的一个工作态度是怎样滴，项目组上的小伙伴我这边都经常做回访，没加班文化和氛围 ，咱们工作强度不大，属于很轻松的舒服稳定性好的企业）
 
 互联网经常要加班的，而且版本迭代上线加班是正常情况

7面试到最后如果面试官问还有什么想了解，基本不要选择在这个时候去问项目用什么技术，因为我发现很多候选人本来是面试挺好，结果最后去问技术问题，就绕道了自己不会的技能上很容易给自己绕进去导致最终面试不通过，基本上这个时候可以说“目前没什么想了解的，公司所做的业务和一些基本情况之前hr也有大概跟我介绍过，非常感谢今天面试机会”

目前没什么想了解的，公司所做的业务和一些基本情况之前hr也有大概跟我介绍过，如果后面还有其他不明白的地方，进入项目组我再向您请教

总而言之，项目是必须要说的很流利，很通畅，多背熟几次，在家对着自己多练习几次回忆回忆，好好巩固，其他就是要学会随机应变，不要太古板，面试要学会随机应变，沟通上面一定要通畅哈，加油哦，有什么不懂随时呼我

南方航空是做订票 商城类系统 到时候介绍自己经验的时候可以往一些商城系统说说，骑马也是点优势来的，可以提前搜搜南方航空网页版就知道做些什么的了

您应聘的是服务平台组：需要具有独立搭建ssm项目经验(只是需要具备能力，实际上进去也不会要求独立完成，都是几个小伙伴一起协同)，实现简单的功能即可，「服务组主要负责选座，服务评价板块的完善，活动实施及开展的链接和功能研发。」

面试官常规面试题：（是之前候选人面试完反馈得到的，不要外泄，仅供自己看哈）
1.	你比较擅长搭建ssm还是微服务框架，是否可以独立搭建，如果给你自己搭建是否有信心完成?

这两个框架在项目中我都有实战的。
最近的项目都是用的微服务，在微服务方面也是积累了一些经验的，之前有过项目也是要自己去搭建这个框架，要我去搭建这个框架是没有问题的。


2.	MySql和 Redis,mongodb的区别；
关系型数据库
优点：以完善的关系代数理论为基础,有严格的标准,支持事务ACID四性,借助索引机制可以实现高效的查询。
缺点：可扩展性差，无法较好地支持海量数据存储，数据模型过于死板，事务机制影响了系统的整体性能，全文搜索功能较弱。
NoSQL数据库
优点：数据之间无关系，易扩展。有非常高的读写性能，支持大量数据，性能高。有灵活的数据模型，无须事先为要存储的数据建立字段，随时可以存储自定义的数据格式。
缺点：复杂查询性能不高,一般都不能实现事务的强一致性
MongoDB和Redis的区别
概念
MongoDB 更类似 MySQL，支持字段索引、游标操作，其优势在于查询功能比较强大，擅长查询 JSON 数据，能存储海量数据，但是不支持事务。
Redis 是一个开源（BSD许可）的，内存中的数据结构存储系统，支持多种类型的数据结构，可用作数据库，高速缓存和消息队列代理。
区别
1、内存管理机制
Redis 数据全部存在内存，定期写入磁盘，当内存不够时，可以选择指定的 LRU 算法删除数据。
MongoDB 数据存在内存，由 linux系统 mmap 实现，当内存不够时，只将热点数据放入内存，其他数据存在磁盘。
2、支持的数据结构
Redis 支持的数据结构丰富，包括hash、set、list等。
MongoDB 数据结构比较单一，但是支持丰富的数据表达，索引，最类似关系型数据库，支持的查询语言非常丰富。
3、数据量和性能：
当物理内存够用的时候，redis>mongodb>mysql
当物理内存不够用的时候，redis和mongodb都会使用虚拟内存。
实际上如果redis要开始虚拟内存，那很明显要么加内存条，要么你换个数据库了。
但是，mongodb不一样，只要，业务上能保证，冷热数据的读写比，使得热数据在物理内存中，mmap的交换较少。
mongodb还是能够保证性能。
4、性能
mongodb依赖内存，TPS较高；Redis依赖内存，TPS非常高。性能上Redis优于MongoDB。
5、可靠性
mongodb从1.8版本后，采用binlog方式（MySQL同样采用该方式）支持持久化，增加可靠性；
Redis依赖快照进行持久化；AOF增强可靠性；增强可靠性的同时，影响访问性能。
可靠性上MongoDB优于Redis。
6、数据分析
mongodb内置数据分析功能（mapreduce）；而Redis不支持。
7、事务支持情况
Redis 事务支持比较弱，只能保证事务中的每个操作连续执行；mongodb不支持事务。
8、集群
MongoDB 集群技术比较成熟，Redis从3.0开始支持集群。

3.	项目中的文件怎么上传上传到什么地方，遇到过什么问题?
通过文件服务上传的本地服务器，文件服务集成了FastDFS，开始沟通的时候文件不会很多，没有启用文件服务

4.	介绍springboot；redis使用；
可独立运行的Spring应用
嵌入式Web容器
固化的starter依赖
自动装配Spring模块或第三方库
产品就绪特性
SpringBoot提供了应用部署产品环境运行所必须的日志、指标、健康检查、外部化配置等特性，为部署后的运维提供工具支持，支撑应用尽可能快的部署到产品环境。
避免或简化配置

存储token信息、做分布式锁

5.	sql优化、分页；接口抽象类；
EXPLAIN
type列，连接类型。一个好的sql语句至少要达到range级别。杜绝出现all级别
key列，使用到的索引名。如果没有选择索引，值是NULL。可以采取强制索引方式
key_len列，索引长度
rows列，扫描行数。该值是个预估值
extra列，详细说明。注意常见的不太友好的值有：Using filesort, Using temporary
 
SQL语句中IN包含的值不应过多
MySQL对于IN做了相应的优化，即将IN中的常量全部存储在一个数组里面，而且这个数组是排好序的。但是如果数值较多，产生的消耗也是比较大的。再例如：select id from table_name where num in(1,2,3) 对于连续的数值，能用 between 就不要用 in 了；再或者使用连接来替换。
SELECT语句务必指明字段名称
SELECT *增加很多不必要的消耗（cpu、io、内存、网络带宽）；增加了使用覆盖索引的可能性；当表结构发生改变时，前断也需要更新。所以要求直接在select后面接上字段名。
当只需要一条数据的时候，使用limit 1
这是为了使EXPLAIN中type列达到const类型
如果排序字段没有用到索引，就尽量少排序
如果限制条件中其他字段没有索引，尽量少用or
or两边的字段中，如果有一个不是索引字段，而其他条件也不是索引字段，会造成该查询不走索引的情况。很多时候使用 union all 或者是union(必要的时候)的方式来代替“or”会得到更好的效果

尽量用union all代替union
union和union all的差异主要是前者需要将结果集合并后再进行唯一性过滤操作，这就会涉及到排序，增加大量的CPU运算，加大资源消耗及延迟。当然，union all的前提条件是两个结果集没有重复数据。
不使用ORDER BY RAND()

区分in和exists， not in和not exists
区分in和exists主要是造成了驱动顺序的改变（这是性能变化的关键），如果是exists，那么以外层表为驱动表，先被访问，如果是IN，那么先执行子查询。所以IN适合于外表大而内表小的情况；EXISTS适合于外表小而内表大的情况。

关于not in和not exists，推荐使用not exists，不仅仅是效率问题，not in可能存在逻辑问题。如何高效的写出一个替代not exists的sql语句？
使用合理的分页方式以提高分页的效率
使用上述sql语句做分页的时候，可能有人会发现，随着表数据量的增加，直接使用limit分页查询会越来越慢。
select id,name from table_name limit 866613, 20
优化的方法如下：可以取前一页的最大行数的id，然后根据这个最大的id来限制下一页的起点。比如此列中，上一页最大的id是866612。sql可以采用如下的写法：
select id,name from table_name where id> 866612 limit 20
分段查询
在一些用户选择页面中，可能一些用户选择的时间范围过大，造成查询缓慢。主要的原因是扫描行数过多。这个时候可以通过程序，分段进行查询，循环遍历，将结果合并处理进行展示。
如下图这个sql语句，扫描的行数成百万级以上的时候就可以使用分段查询
避免在 where 子句中对字段进行 null 值判断
对于null的判断会导致引擎放弃使用索引而进行全表扫描。
不建议使用%前缀模糊查询
这种查询会导致索引失效而进行全表扫描。但是可以使用LIKE “name%”。那如何查询%name%？
那么如何解决这个问题呢，答案：使用全文索引
避免在where子句中对字段进行表达式操作
select user_id,user_project from table_name where age*2=36;
中对字段就行了算术运算，这会造成引擎放弃使用索引，建议改成
select user_id,user_project from table_name where age=36/2;
避免隐式类型转换
where 子句中出现 column 字段的类型和传入的参数类型不一致的时候发生的类型转换，建议先确定where中的参数类型
对于联合索引来说，要遵守最左前缀法则
举列来说索引含有字段id,name,school，可以直接用id字段，也可以id,name这样的顺序，但是name，school都无法使用这个索引。所以在创建联合索引的时候一定要注意索引字段顺序，常用的查询字段放在最前面

必要时可以使用force index来强制查询走某个索引
有的时候MySQL优化器采取它认为合适的索引来检索sql语句，但是可能它所采用的索引并不是我们想要的。这时就可以采用force index来强制优化器使用我们制定的索引。
注意范围查询语句
对于联合索引来说，如果存在范围查询，比如between,>,<等条件时，会造成后面的索引字段失效。

关于JOIN优化
•	LEFT JOIN A表为驱动表
•	INNER JOIN MySQL会自动找出那个数据少的表作用驱动表
•	RIGHT JOIN B表为驱动表
•	尽量使用inner join，避免left join
•	合理利用索引
被驱动表的索引字段作为on的限制字段。
利用小表去驱动大表


6.	多线程；单点登录；Nginx；
单点登录：
单一服务器模式登录
*登陆成功后，把用户数据放到session里面                     session.setAttribute("user",user)
*判断是否登录，从session获取数据，可以获取到登录   session.getAttribute("user")
集群部署
session广播机制实现
在一个集群中的一个模块登录后，然后把这个session复制n份，发送到这个集群的其他模块中，就实现了一处登录，处处可用，但缺点是耗费比较大，不推荐使用
使用cookie+redis实现
把cookie获取值，到redis进行查询，根据key进行查询，如果查询数据就是登录
使用token实现(推荐使用)
按照一定规则生成字符串，字符串可以包含用户信息

7.	（一定会问的）Mysql   oracle  redis 三者区别？ 
Mysql： 是轻量级的关系型数据库；开源使用成本较低，安全性较低
Oracle：是重量级的对象型数据库、收费、闭源使用成本较高
Redis： 是一个基于内存高性能的key-value数据库、速度快，因为数据存在内存、支持事务，操作都是原子性

8.	redis和ES的区别？
Redis： 是一个基于内存高性能的key-value数据库、速度快，因为数据存在内存、支持事务，操作都是原子性

严格的说，ES不是一个数据库，而是一个搜索引擎，ES的方方面面也都是围绕搜索设计的。ES支持全文搜索，缺点：最明显的就是字段类型无法修改、写入性能较低和高硬件资源消耗
存储方式： 索引  -> 文档 – > 字段


9.	ES和新组建的原理和包括哪些？


10.	 Mysql ，oracle针对预期的处理，分别有什么优缺点？（不会的话提前知乎百度搜搜）
Msql:
将sql语句强制一分为二：
第一部分为前面相同的命令和结构部分
第二部分为后面可变的数据部分
在执行sql语句的时候，首先将前面相同的命令和结构部分发送给MySQL服务器，让MySQL服务器事先进行一次预处理(此时并没有真正的执行sql语句)，而为了保证sql语句的结构完整性，在第一次发送sql语句的时候将其中可变的数据部分都用一个数据占位符来表示！比如问号？就是常见的数据占位符！
Oracle：
外部表External Table的核心在于定义数据表时候的描述参数，Preprocessor特性实际上就是外部表定义过程中的一个参数项目。使用Preprocessor参数有配套参数项目，用于详细指定出究竟处理文本文件的函数是谁？在哪？directory_spec参数是可选项目，如果处理函数位置和默认Directory不同，就是用这个来指定。File_spec就是指定的函数处理程序对象。
从系统部署角度看，处理程序(加密或者压缩)和数据放在相同的位置显然不是一个好主意，同时也不是规范安全的做法。

优缺点：？？？？

11.	 ES底层原理是什么？？
倒排索引
ES使用倒排索引的结构进行全文快速搜索，一个倒排索引由文档中所有不重复的列表构成，对于每一个单词，有一个包含他的文档列表。 
标准化规则
为解决词条检索时词条命中率问题，ES在建立倒排索引时运用标准化规则即针对存储的索引词条进行一些相关预处理再作为索引进行存储。
这就是标准化规则转换，主要包括：时态的转换、单复数的转换、同义词的转换、大小写的转换
相关度分数的计算
相关度分数的计算基于TF/IDF算法（Term Frequence&Inverse Doucument Frequency），翻译大意为：词条在文档中出现的频率及在倒排索引中出现的频率。
1.Term Frequence：我们查询的词条在文本中出现多少次，出现次数越多，相关度越高。
ES分布式架构
ES集群通过自定义的一些机制来保证集群条件下的扩展性，效率及事务性等特性
分片和副本机制
ES利用分片机制将用户数据分节点存储，保证存储效率以及数据安全性。
扩容机制
水平扩容：增加服务器个数。垂直扩容：在服务器台数不变情况下，单个服务器容量扩大。
数据路由机制
数据增删改查机制
写一致性原理和quorum机制

12.	什么场景用redis？什么场景用mysql？
13.	你是如何理解微服务的？回答：微服务原理，（可以提前知乎搜搜）组件

14.	最近的项目负责了哪些模块，遇到什么难点，是怎么解决
15.	看到您的项目上Xxx模块那里如果大数据量怎么处理，不导致服务雪崩？
16.	Linux会用吗？
17.	熟悉的设计模式，有哪些优缺点？怎么用？
18.	接受加班吗？（面试官想看一下您的工作态度，实际国企没加班氛围，一个月撑死一次版本迭代上线，加班是有加班费的或者可以申请调休）
互联网经常要加班的，而且版本迭代上线加班是正常情况
19.	用了那些微服务框架？？
20.	安全问题，加密，怎么解决？
21.	 sql语句、怎样实现多表联查
16. 高并发项目的描述

直接问问题：数组去重、高并发、多线程、线程池
1、面试官主要问的问题：负责的模块，实现的流程细节，java有哪几种锁
2、面试官问到的知识盲区：redis的分布式锁的实现
3、设计模式，工作中设计模式场景说下，线程池，线程池的参数有哪些，线程场景题，redis参数，项目工作中的场景问题，比如如何避免秒杀时超卖，库存如何增加
面试反馈：
1、Java技术基础：多线程（线程池）2、SQL查询、结构优化的方法、设计表、数据量最多是多少（要求几百万）
2、商城所用技术：double（遇到问题怎么解决）、分布式（分布式锁）、高并发 
商旅的技术点：
Spring MVC、MyBatis、SpringBoot、框架之间的区别；
SQL相关的索引、联表、等等；
RocketMQ、Redis 

1.就做过的项目进行提问，通过项目介绍问到订单创建，请求数据订单幂等性，怎么避免创建多个订单问题。
MQ,运行是单机运行还是分布式运行数据查询慢的原因，用户表数据量是对多少，多线池参数及意义
2.技术栈：redis数据结构，存储，集群spring boot，mybatis怎么实现幂等性，dubbo框架 

你做的项目内容以及里面的技术点，然后问你项目哪些地方用到sql优化，具体是怎么优化的
- spring的aop实现
- Spring解决的循环依赖
- Sping的传播机制
- 多线程交替打印奇偶数
- 锁volatile怎么用
- 主键和普通索引的区别，查询上有什么不同
工作中遇到慢查询怎么优化的
我项目里面mysql怎么优化
为什么需要加activemq发送id
线程池参数及创建方式；Redis的穿透、雪崩、击穿；Spring的事务等等

下面是高级Java岗位需要重点准备的：（中级看个人需求简单看看即可）
-服务组-高级Java
在回答问题时，把前因后果讲一下，不要单独去回答问题，可以显得出自己的思路
1、自我介绍
2、佰均成（南方航空）
3、 负责哪些模块开发，用到什么技术
4、 k8s 的了解
Kubernetes是一个全新的基于容器技术的分布式系统支撑平台。在Docker技术的基础上，为容器化的应用提供部署运行、资源调度、服务发现和动态伸缩等一系列完整功能
5、 微服务理解
微服务是在 SOA 上做的升华，微服务架构强调的一个重点是“业务需要彻底的组件化和服务化”，原有的单个业务系统会拆分为多个可以独立开发、设计、运行的小应用。这些小应用之间通过服务完成交互和集成。

6、 是否可以独立搭建微服务
7、 SOA 架构的理解
“面向服务的架构”:他是一种设计方法，其中包含多个服务， 服务之间通过相互依赖最终提供一系列的功能。一个服务 通常以独立的形式存在与操作系统进程中。各个服务之间 通过网络调用。
8、sql 优化负责了哪些优化
9、 elk的理论知识点
1.1、Elasticsearch是个开源分布式搜索引擎，提供搜集、分析、存储数据三大功能。它的特点有：分布式，零配置，自动发现，索引自动分片，索引副本机制，restful风格接口，多数据源，自动搜索负载等。
1.2、Logstash 主要是用来日志的搜集、分析、过滤日志的工具，支持大量的数据获取方式。一般工作方式为c/s架构，client端安装在需要收集日志的主机上，server端负责将收到的各节点日志进行过滤、修改等操作在一并发往elasticsearch上去。
1.3、Kibana 也是一个开源和免费的工具，Kibana可以为 Logstash 和 ElasticSearch 提供的日志分析友好的 Web 界面，可以帮助汇总、分析和搜索重要数据日志。
10、 es 有哪些核心模块
DistributedLucene Directory 它是Lucene里的一些列索引文件组成的目录
River，代表是数据源。是以插件的形式存在于ES中
Mapping，映射的意思，非常类似于静态语言中的数据类型
Search Moudle，搜索模块，支持搜索的一些常用操作
Index Moudle，索引模块，支持索引的一些常用操作
Disvcovery，主要是负责集群的master节点发现。比如某个节点突然离开或进来的情况，进行一个分片重新分片等。这里有个发现机制。

11、 系统的用户访问量
12、 怎么解决高并发的问题
1：系统拆分，将一个系统拆分为多个子系统，用dubbo来搞。然后每个系统连一个数据库，这样本来就一个库，现在多个数据库，这样就可以抗高并发。

2：缓存，必须得用缓存。大部分的高并发场景，都是读多写少，那你完全可以在数据库和缓存里都写一份，然后读的时候大量走缓存不就得了。毕竟人家redis轻轻松松单机几万的并发啊。没问题的。所以你可以考的虑考虑你的项目里，那些承载主要请求读场景，怎么用缓存来抗高并发。

3：MQ(消息队列)，用MQ吧，大量的写请求灌入MQ里，排队慢慢玩儿，后边系统消费后慢慢写，控制在mysql承载范围之内。所以你得考虑考虑你的项目里，那些承载复杂写业务逻辑的场景里，如何用MQ来异步写，提升并发性。MQ单机抗几万并发也是ok的。

4：分库分表，可能到了最后数据库层面还是免不了抗高并发的要求，好吧，那么就将一个数据库拆分为多个库，多个库来抗更高的并发；然后将一个表拆分为多个表，每个表的数据量保持少一点，提高sql跑的性能。

5：读写分离，这个就是说大部分时候数据库可能也是读多写少，没必要所有请求都集中在一个库上吧，可以搞个主从架构，主库写入，从库读取，搞一个读写分离。读流量太多的时候，还可以加更多的从库。

13、mysql 和 oracle 的区别
Mysql： 是轻量级的关系型数据库；开源使用成本较低，安全性较低
Oracle：是重量级的对象型数据库、收费、闭源使用成本较高

14、 mysql 和 oracle 对时间格式的处理有什么区别
MYSQL日期字段分DATE和TIME两种，ORACLE日期字段只有DATE，包含年月日时分秒信息，用当前数据库的系统时间为 SYSDATE，精确到秒，或者用字符串转换成日期型函数TO_DATE(‘2001-08-01’,’YYYY-MM-DD’)年-月-日24小时:分 钟:秒的格式YYYY-MM-DD HH24:MI:SS TO_DATE()还有很多种日期格式，可以参看ORACLE DOC.日期型字段转换成字符串函数TO_CHAR(‘2001-08-01’,’YYYY-MM-DD HH24:MI:SS’)

日期字段的数学运算公式有很大的不同。MYSQL找到离当前时间7天用DATE_FIELD_NAME > SUBDATE(NOW()，INTERVAL 7 DAY)ORACLE找到离当前时间7天用 DATE_FIELD_NAME >SYSDATE - 7;

MYSQL中插入当前时间的几个函数是：NOW()函数以`'YYYY-MM-DD HH:MM:SS'返回当前的日期时间，可以直接存到DATETIME字段中。CURDATE()以’YYYY-MM-DD’的格式返回今天的日期，可以 直接存到DATE字段中。CURTIME()以’HH:MM:SS’的格式返回当前的时间，可以直接存到TIME字段中。例：insert into tablename (fieldname) values (now())

而oracle中当前时间是sysdate

15、开始针对简历上您写的【专业技能或者个人技能】板块去挑选几个来问你原理
3、最近项目，自己主要负责哪些功能
4、是否用过微服务框架/工具？
5、Redis和ES的区别
6、是否用ES做检索
7、是否可以独立搭建微服务框架？
8、Java里hash map 和hash table的区别
9、怎么理解并发？
10、用多线程需要注意什么问题？
11、是否做过或了解JVM调优？（估计是会的话最好）
12、现居哪里。

1、是否有知道新同事工作？
2、怎么安排代码和代码review的？
3、针对过往工作中是否有印象深刻的优化工作？

这是服务组高级Java上次问的（如果面试高级才需要准备，中级可以跳过）：问了项目中框架，比如我写的dubbo ，就问了它的工作原理，还有数据迁移中有哪些遇到过哪些困难和问题。还有spring swage之类的一些问题，基本围绕着项目做的广告是根据什么去推送到具体的人之类的Redis和mq这些，项目中用到的也都问了。

